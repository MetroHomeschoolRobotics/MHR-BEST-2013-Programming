#pragma config(Motor,  port2,           arm,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           extend,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           lClaw,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           rClaw,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           wrist,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           turret,        tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 8U = Toggle Free Arm Movement
// 7U = Flip Arm Controls
// Left Y (Ch3) + 6U = Arm
// Right X (Ch2) + 6D = Turret
// 7L = LClaw Open
// 7R = LClaw Close
// 8R = RClaw Open
// 8L = RClaw Close
// 7D = Both Claws Open
// 8D = Both Claws Close
// 5U = Extend
// 5D = Retract

int rightX; // Holds Right Stick's X Position
int rightY; // Holds Right Stick's Y Position
int leftX; // Holds Left Stick's X Position
int leftY; // Holds Left Stick's Y Position
const bool on = true; // ALIVE!!!!!!
bool free = false;
bool toggling = false;
bool armFlip = false;
int armPower = 0;
int coastGuard = 15;
float rightClawPos = 0.0;
float leftClawPos = 100.0;

void armMovement() {
	// Single-button Toggles
	if(!toggling) {
		if(vexRT[Btn7U]) {
			toggling = true;
			armFlip = !armFlip;
		}
		if(vexRT[Btn8U]) {
			toggling = true;
			free = !free;
		}
	} else {
		if(!(vexRT[Btn7U] || vexRT[Btn8U])) {
			toggling = false;
		}
	}

	// Reworked arm/turret free toggle thingy
	if (free) {
		motor[turret] = -leftX;
		armPower = leftY;
	} else {
		// Turret Movement
		if(vexRT[Btn6D]) {
			motor[turret] = -leftX;
		} else {
			motor[turret] = 0;
		}

		// Arm Movement
		if(vexRT[Btn6U]) {
			armPower = leftY;
		} else {
			armPower = 0;
		}
	}

	// Telescope Movement
	if(vexRT[Btn5D]) {
		motor[extend] = 90;
	} else if(vexRT[Btn5U]) {
		motor[extend] = -90;
	} else {
		motor[extend] = 0;
	}

	//Wrist Movement
	if(rightY > 10) {
		motor[wrist] = rightY;
	} else if(rightY < -10) {
		motor[wrist] = rightY;
	} else {
		motor[wrist] = 0;
	}
	
	// Adjust arm power to keep it from coasting
	if(!armFlip) {
		motor[arm] = armPower+coastGuard;
	} else {
		motor[arm] = -armPower-coastGuard;
	}
}

void claw() {
	// Claw Movement
	if(!armFlip) {
		// Left Claw
		if(vexRT[Btn7L]) { // Open
			if(leftClawPos < 100.0) {
				leftClawPos = leftClawPos + 1;
			}
		} else if(vexRT[Btn7R]) { // Close
			if(leftClawPos > 0.0) {
				leftClawPos = leftClawPos - 1;
			}
		}

		// Right Claw
		if(vexRT[Btn8R]) { // Open
			if(rightClawPos > 0.0) {
				rightClawPos = rightClawPos - 1;
			}
		} else if(vexRT[Btn8L]) { // Close
			if(rightClawPos < 100.0) {
				rightClawPos = rightClawPos + 1;
			}
		}
	} else {
		// Left Claw
		if(vexRT[Btn8R]) { // Open
			if(leftClawPos < 100.0) {
				leftClawPos = leftClawPos + 1;
			}
		} else if(vexRT[Btn8L]) { // Close
			if(leftClawPos > 0.0) {
				leftClawPos = leftClawPos - 1;
			}
		}

		// Right Claw
		if(vexRT[Btn7L]) { // Open
			if(rightClawPos > 0.0) {
				rightClawPos = rightClawPos - 1;
			}
		} else if(vexRT[Btn7R]) { // Close
			if(rightClawPos < 100.0) {
				rightClawPos = rightClawPos + 1;
			}
		}
	}

	// Both Claws
	if(vexRT[Btn8D]) { // Open
		if(leftClawPos < 100.0) {
			leftClawPos = leftClawPos + 1;
		}
		if(rightClawPos > 0.0) {
			rightClawPos = rightClawPos - 1;
		}
	} else if(vexRT[Btn7D]) { // Close
		if(leftClawPos > 0.0) {
			leftClawPos = leftClawPos - 1;
		}
		if(rightClawPos < 100.0) {
			rightClawPos = rightClawPos + 1;
		}
	}

	// Range of motion limiter to protect claw servos from being stripped.
	motor[lClaw] = ((leftClawPos/100.0)*87.0)+40.0;
	motor[rClaw] = ((rightClawPos/100.0)*72)-7;

	wait1Msec(5); // Allow slow claw movement
}

task main() {
	while(on) {
		// Update input variables once per cycle
		rightX = vexRT[Ch1];
		rightY = vexRT[Ch2];
		leftX = vexRT[Ch4];
		leftY = vexRT[Ch3];
		
		// Run robot control code from above
		armMovement();
		claw();
	}
}
