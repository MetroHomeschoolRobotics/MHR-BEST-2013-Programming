#pragma config(Sensor, dgtl1,  fArmStop,            sensorDigitalIn)
#pragma config(Sensor, dgtl2,  rArmStop,            sensorDigitalIn)
#pragma config(Motor,  port2,           ldrive,        tmotorNormal, openLoop)
#pragma config(Motor,  port3,           smotor1,       tmotorNormal, openLoop)
#pragma config(Motor,  port4,           serv1,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           serv2,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           serv3,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           serv4,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           smotor2,       tmotorNormal, openLoop)
#pragma config(Motor,  port9,          rdrive,        tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task Drive() {
	int RightX;
	int RightY;
	int RightXsq;
	int RightYsq;
	int RightXcu;
	int RightYcu;
	int threshold = 10;
	int drivesystem = 2;
	int slow = 1;
	int ldmotor;
	int rdmotor;
	int backwards = 1;

	while (true){
		RightX = vexRT[Ch1];
		RightY = vexRT[Ch2];
    if(vexRT[Ch1] >= 0)
      RightXsq = (vexRT[Ch1] * vexRT[Ch1]) / 127;
    if(vexRT[Ch1] < 0)
      RightXsq = -((vexRT[Ch1] * vexRT[Ch1]) / 127);
    if(vexRT[Ch2] >= 0)
      RightYsq = (vexRT[Ch2] * vexRT[Ch2]) / 127;
    if(vexRT[Ch2] < 0)
      RightYsq = -((vexRT[Ch2] * vexRT[Ch2]) / 127);

    RightXcu = (((vexRT[Ch1] * vexRT[Ch1]) / 127) * vexRT[Ch1]) / 127;
    RightYcu = (((vexRT[Ch2] * vexRT[Ch2]) / 127) * vexRT[Ch2]) / 127;


/*  This is for toggling the drive between normal, squared, and cubed.
    Disabled for competition as it was originally just for testing of controls.
    if(drivesystem == 0 && vexRT[Btn8U]) {
      while(vexRT[Btn8U])
        drivesystem = 1;
    } else if(drivesystem == 1 && vexRT[Btn8U]) {
      while(vexRT[Btn8U])
        drivesystem = 2;
    } else if(drivesystem == 2 && vexRT[Btn8U]) {
      while(vexRT[Btn8U])
        drivesystem = 0;
    }
*/


    if(drivesystem == 0) { //Normal
  		if(RightY > threshold) { // Forwards
  			ldmotor = (RightY + RightX)^2/127;
			  rdmotor = (RightY - RightX)^2/127;
		  }		else if(RightY < -threshold) { // Backwards
  			ldmotor = (RightY + RightX)^2/127;
			  rdmotor = (RightY - RightX)^2/127;
		  } 	else if((abs(RightX) > threshold) && (abs(RightY) < threshold)) { // Turning in Place
  			ldmotor = RightX;
			  rdmotor = (-1 * RightX);
		  }		else { // If no controls held, disable motors
  			ldmotor = 0;
			  rdmotor = 0;
		  }

  	} else if(drivesystem == 1) { // Squared
  		if(RightY > threshold) { // Forwards
  			ldmotor = (RightYsq + RightXsq)^2/127;
			  rdmotor = (RightYsq - RightXsq)^2/127;
		  }		else if(RightY < -threshold) { // Backwards
  			ldmotor = (RightYsq + RightXsq)^2/127;
			  rdmotor = (RightYsq - RightXsq)^2/127;
		  } 	else if((abs(RightX) > threshold) && (abs(RightY) < threshold)) { // Turning in Place
  			ldmotor = RightXsq;
			  rdmotor = (-1 * RightXsq);
		  }		else { // If no controls held, disable motors
  			ldmotor = 0;
			  rdmotor = 0;
		  }
    } else if(drivesystem == 2) { // Cubed
  		if(RightY > threshold) { // Forwards
  			ldmotor = (RightYcu + RightXcu)^2/127;
			  rdmotor = (RightYcu - RightXcu)^2/127;
		  }		else if(RightY < -threshold) { // Backwards
  			ldmotor = (RightYcu + RightXcu)^2/127;
			  rdmotor = (RightYcu - RightXcu)^2/127;
		  } 	else if((abs(RightX) > threshold) && (abs(RightY) < threshold)) { // Turning in Place
  			ldmotor = RightXcu;
			  rdmotor = (-1 * RightXcu);
		  }		else { // If no controls held, disable motors
  			ldmotor = 0;
			  rdmotor = 0;
		  }
    } else { //Normal again
  		if(RightY > threshold) { // Forwards
  			ldmotor = (RightY + RightX)/127;
			  rdmotor = (RightY - RightX)/127;
		  }		else if(RightY < -threshold) { // Backwards
  			ldmotor = (RightY + RightX)/127;
			  rdmotor = (RightY - RightX)/127;
		  } 	else if((abs(RightX) > threshold) && (abs(RightY) < threshold)) { // Turning in Place
  			ldmotor = RightX;
			  rdmotor = (-1 * RightX);
		  }		else { // If no controls held, disable motors
  			ldmotor = 0;
			  rdmotor = 0;
		  }
    }


    if(vexRT[Btn7L])
      slow = 1;
    else if(vexRT[Btn7D])
      slow = 0;

    if(vexRT[Btn7U])
      backwards = 0;
    else if(vexRT[Btn7R])
      backwards = 1;

    if(slow) {
      if(backwards) {
        motor[ldrive] = -(0.5 * rdmotor);
        motor[rdrive] = -(0.5 * ldmotor);
      } else {
        motor[ldrive] = 0.5 * ldmotor;
        motor[rdrive] = 0.5 * rdmotor;
      }
    } else {
      if(backwards) {
        motor[ldrive] = -rdmotor;
        motor[rdrive] = -ldmotor;
      } else {
        motor[ldrive] = ldmotor;
        motor[rdrive] = rdmotor;
      }
    }



  }
}

task Motors() {
  int LeftX;
  int LeftY;
  int threshold = 10;
  int LeftYsq;
  while(true) {
    LeftX = vexRT[Ch4]; // Initialize Joystick variables
    LeftY = vexRT[Ch3];
    if(vexRT[Ch3] >= 0)
      LeftYsq = (vexRT[Ch3] * vexRT[Ch3]) / 127;
    if(vexRT[Ch3] < 0)
      LeftYsq = -((vexRT[Ch3] * vexRT[Ch3]) / 127);


    if(vexRT[Btn5U]) {
      motor(serv1) = -127;
      motor(serv2) = 127;
    } else if(vexRT[Btn5D]) {
      motor(serv1) = 127;
      motor(serv2) = -127;
    } else if(vexRT[Btn6D]) {
      motor(serv1) = LeftY;
      motor(serv2) = -LeftY;
    }


    if(vexRT[Btn6U]) { // Arm Movement Code
      if( ( LeftYsq > 5 )  && ( SensorValue(fArmStop) )  ) {
        motor[smotor1] = LeftYsq;
      } else if( ( LeftYsq < -5 )  && ( SensorValue(rArmStop) )  ) {
        motor[smotor1] = LeftYsq;
      } else {
        motor[smotor1] = 0;
      }
    } else {
      motor[smotor1] = 0;
    }
  }
}


task main() {
  StartTask(Drive);
  StartTask(Motors);
  int on = true;
  while(on){}
}
